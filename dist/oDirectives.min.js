angular.module('ui.bootstrap.pagination', [])

.controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page) {
    if ( $scope.page !== page && page > 0 && page <= $scope.totalPages) {
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function( key ) {
    return $scope[key + 'Text'] || self.config[key + 'Text'];
  };
  $scope.noPrevious = function() {
    return $scope.page === 1;
  };
  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };

  $scope.$watch('totalItems', function() {
    $scope.totalPages = self.calculateTotalPages();
  });

  $scope.$watch('totalPages', function(value) {
    setNumPages($scope.$parent, value); // Readonly variable

    if ( $scope.page > value ) {
      $scope.selectPage(value);
    } else {
      ngModelCtrl.$render();
    }
  });
}])

.constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@'
    },
    require: ['pagination', '?ngModel'],
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pagination.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );

        // recompute if maxSize
        if ( isMaxSized ) {
          if ( rotate ) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if ( isMaxSized && ! rotate ) {
          if ( startPage > 1 ) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }

          if ( endPage < totalPages ) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page > 0 && scope.page <= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: '« Previous',
  nextText: 'Next »',
  align: true
})

.directive('pager', ['pagerConfig', function(pagerConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@'
    },
    require: ['pager', '?ngModel'],
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pager.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

(function(module) {
try {
  module = angular.module('envoc.directives.partials');
} catch (e) {
  module = angular.module('envoc.directives.partials', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('/oTemplates/datatables/oTableDefault.tmpl.html',
    '<pre>{{ctrl.state|json}}</pre>\n' +
    '<div class="dataTables_wrapper form-inline" role="grid">\n' +
    '    <div class="row">\n' +
    '        <div class="span6 pull-left">\n' +
    '            <div class="dataTables_length">\n' +
    '                <label>\n' +
    '                    Show\n' +
    '                    <select size="1" ng-model="ctrl.state.linesPerPage">\n' +
    '                        <option value="10">10</option>\n' +
    '                        <option value="25">25</option>\n' +
    '                        <option value="50">50</option>\n' +
    '                        <option value="100">100</option>\n' +
    '                    </select>\n' +
    '                    entries\n' +
    '                </label>\n' +
    '            </div>\n' +
    '        </div>\n' +
    '        <div class="span6 pull-right">\n' +
    '            <div class="dataTables_filter">\n' +
    '                <label>\n' +
    '                    Search:\n' +
    '                    <input type="text" ng-model="ctrl.state.allSearch">\n' +
    '                </label>\n' +
    '            </div>\n' +
    '        </div>\n' +
    '    </div>\n' +
    '\n' +
    '    <table class="table table-striped dataTable">\n' +
    '        <thead>\n' +
    '            <tr role="row"></tr>\n' +
    '        </thead>\n' +
    '\n' +
    '        <tbody role="alert" aria-live="polite" aria-relevant="all">\n' +
    '            <tr ng-repeat="row in ctrl.data">\n' +
    '            </tr>\n' +
    '        </tbody>\n' +
    '    </table>\n' +
    '\n' +
    '    <div class="row">\n' +
    '        <div class="span6 pull-left">\n' +
    '            <div class="dataTables_info" id="user-table_info">\n' +
    '                Showing\n' +
    '                {{ctrl.state.pageStartIdx + 1}}\n' +
    '                to {{ctrl.state.pageStopIdx}}\n' +
    '                of\n' +
    '                {{ctrl.state.iTotalDisplayRecords}}\n' +
    '                entries\n' +
    '                <span ng-show="ctrl.state.iTotalRecords !== ctrl.state.iTotalDisplayRecords">\n' +
    '                    (filtered from {{ctrl.state.iTotalRecords}})\n' +
    '                </span>\n' +
    '                </div>\n' +
    '        </div>\n' +
    '\n' +
    '        <div class="span6 pull-right">\n' +
    '            <div class="dataTables_paginate paging_bootstrap">\n' +
    '                <pagination total-items="ctrl.state.iTotalDisplayRecords" items-per-page="ctrl.state.linesPerPage" ng-model="ctrl.state.currentPage"></pagination>\n' +
    '            </div>\n' +
    '        </div>\n' +
    '    </div>\n' +
    '</div>\n' +
    '');
}]);
})();

(function(module) {
try {
  module = angular.module('envoc.directives.partials');
} catch (e) {
  module = angular.module('envoc.directives.partials', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('/oTemplates/validation/oValidationMessageFor.tmpl.html',
    '﻿<div>\n' +
    '    <!-- This is where the content of the tag gets replaced -->\n' +
    '    <div ng-transclude></div>\n' +
    '\n' +
    '    <!-- Errors here -->\n' +
    '    <ul class="list-unstyled" ng-show="matches.length" ng-class="{\'alert alert-danger\': matches.length}">\n' +
    '        <li ng-repeat="error in matches">\n' +
    '            <span class="field-validation-error">{{error.errorMessage}}</span>\n' +
    '        </li>\n' +
    '    </ul>\n' +
    '</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('envoc.directives.partials');
} catch (e) {
  module = angular.module('envoc.directives.partials', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('template/pagination/pager.html',
    '<ul class="pager">\n' +
    '  <li ng-class="{disabled: noPrevious(), previous: align}"><a href ng-click="selectPage(page - 1)">{{getText(\'previous\')}}</a></li>\n' +
    '  <li ng-class="{disabled: noNext(), next: align}"><a href ng-click="selectPage(page + 1)">{{getText(\'next\')}}</a></li>\n' +
    '</ul>');
}]);
})();

(function(module) {
try {
  module = angular.module('envoc.directives.partials');
} catch (e) {
  module = angular.module('envoc.directives.partials', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('template/pagination/pagination.html',
    '<ul class="pagination">\n' +
    '  <li ng-if="boundaryLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(1)">{{getText(\'first\')}}</a></li>\n' +
    '  <li ng-if="directionLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(page - 1)">{{getText(\'previous\')}}</a></li>\n' +
    '  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active}"><a href ng-click="selectPage(page.number)">{{page.text}}</a></li>\n' +
    '  <li ng-if="directionLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(page + 1)">{{getText(\'next\')}}</a></li>\n' +
    '  <li ng-if="boundaryLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(totalPages)">{{getText(\'last\')}}</a></li>\n' +
    '</ul>');
}]);
})();

(function() {
    'use strict';

    angular.module('envoc.directives', [
        'envoc.directives.validation',
        'envoc.directives.datatables'
    ]);
})();
(function() {
    'use strict';

    angular.module('envoc.directives.validation', ['envoc.directives.partials']);
})();
﻿(function() {
    'use strict';

    angular
        .module('envoc.directives.validation')
        .directive('oValidateWith', [
            function() {
                return {
                    restrict: 'EA',
                    scope: {
                        errors: "="
                    },
                    controller: function() {},
                    link: function(scope, element, attrs, ctrl) {
                        scope.$watch('errors', function(current) {
                            if (current) {
                                ctrl.errors = scope.errors;
                            }
                        });
                    }
                };
            }
        ]);
})();
﻿(function() {
    'use strict';

    angular
        .module('envoc.directives.validation')
        .directive('oValidationMessageFor', [
            function() {
                return {
                    restrict: 'EA',
                    require: '^oValidateWith',
                    templateUrl: '/oTemplates/validation/oValidationMessageFor.tmpl.html',
                    transclude: true,
                    scope: true,
                    link: function(scope, element, attr, oValidateWithCtrl) {
                        var key = attr.oValidationMessageFor.toLowerCase();
                        scope.errors = oValidateWithCtrl.errors;

                        scope.$watch(getErrors, function(current, previous) {
                            if (current) {
                                scope.matches = current.filter(function(error) {
                                    return error.propertyName.toLowerCase() == key;
                                });
                            }
                        });

                        function getErrors() { return oValidateWithCtrl.errors; }
                    }
                };
            }
        ]);
})();
(function() {
    'use strict';

    angular.module('envoc.directives.datatables', [
        'envoc.directives.partials',
        'ui.bootstrap.pagination'
    ]);
})();
(function() {
    'use strict';

    angular
        .module('envoc.directives.datatables')
        .filter('startFrom', function() {
            return function(input, start) {
                if (input === undefined) {
                    return input;
                } else {
                    return input.slice(+start);
                }
            };
        })
        .controller('oTableCtrl', function($scope, $http, $filter) {
            var config,
                dataCache = [],
                self = this,
                limitTo = $filter('limitTo'),
                filter = $filter('filter'),
                startFrom = $filter('startFrom');

            this.state = {
                currentPage: 1,
                linesPerPage: 10,
                iTotalRecords: 0,
                iTotalDisplayRecords: 0,
                allSearch: ''
            };

            this.events = {};

            this.init = function(config_) {
                config = config_;
                if (!config.dataSrcUrl && !config.dataSrc) {
                    throw new Error('A data source is required');
                }

                if (config.dataSrcUrl) {
                    this.fetch()
                } else {
                    initClientSide();
                }
            }

            this.fetch = function() {
                $http
                    .post(config.dataSrcUrl)
                    .then(dataFetchSuccess, dataFetchError);

                function dataFetchSuccess(resp) {
                    self.data = resp.data;
                }

                function dataFetchError() {
                    alert('Error fetching data');
                }
            }

            function initClientSide(){
                dataCache = config.dataSrc;
                self.state.iTotalRecords = self.state.iTotalDisplayRecords = config.dataSrc.length;
                calculateVisible();
                setupWatches();
            }

            function calculateVisible(){
                var clone = angular.copy(dataCache);

                if(self.state.allSearch){
                    clone = filter(clone, self.state.allSearch);
                    self.state.iTotalDisplayRecords = clone.length;
                } else {
                    self.state.iTotalDisplayRecords = dataCache.length;
                }

                self.state.pageStartIdx = (self.state.currentPage - 1) * self.state.linesPerPage;
                
                // handle going off the page
                while (self.state.pageStartIdx > clone.length){
                    self.state.currentPage--;
                    self.state.pageStartIdx = (self.state.currentPage - 1) * self.state.linesPerPage;
                }

                self.data = limitTo(startFrom(clone, self.state.pageStartIdx), self.state.linesPerPage);
                self.state.pageStopIdx = self.state.pageStartIdx + self.data.length
            }

            function setupWatches(){
                $scope.$watch(watchCurrentPage, calculateVisible);
                $scope.$watch(watchLinesPerPage, calculateVisible);
                $scope.$watch(watchAllSearch, calculateVisible);
            }

            function watchCurrentPage(){
                return self.state.currentPage;
            }

            function watchLinesPerPage(){
                return self.state.linesPerPage;
            }

            function watchAllSearch(){
                return self.state.allSearch;
            }
        })
        .directive('oTable', function() {
            return {
                priority: 800,
                restrict: 'EA',
                scope: {
                    config: '='
                },
                controller: 'oTableCtrl',
                controllerAs: 'oTableCtrl',
                compile: function compile(tElement, tAttrs, transclude) {
                    return function postLink(scope, iElement, iAttrs, controller) {
                        controller.init(scope.config);
                    }
                }
            };
        });
})();

(function() {
    'use strict';

    angular
        .module('envoc.directives.datatables')
        .directive('oTableDefault', function() {
            return {
                templateUrl: '/oTemplates/datatables/oTableDefault.tmpl.html',
                require: '^oTable',
                restrict: 'EA',
                scope: {},
                compile: function compile(tElement, tAttrs, transclude) {
                    if(!tAttrs.fields) {
                        throw new Error('No filed list included');
                    }

                    var theBodyRow = tElement.find('tbody').find('tr');
                    var theHeadRow = tElement.find('thead').find('tr');

                    var theFields = tAttrs.fields.split(',');

                    buildTemplate(theHeadRow, '<td>', '</td>', theFields);

                    buildTemplate(theBodyRow, '<td>{{row.', '}}</td>', theFields);

                    function buildTemplate(theRow, startTemplate, endTemplate, fields) {
                        var fieldTemplate = startTemplate + fields.join(endTemplate + startTemplate) + endTemplate;

                        theRow.html(fieldTemplate);
                    }

                    return function postLink(scope, iElement, iAttrs, controller) {
                        ctor();
                        function ctor() {
                            scope.ctrl = controller;
                            scope.$watch(getOTableData, applyToScope);
                        }

                        function getOTableData() {
                            return controller.data;
                        }

                        function applyToScope(current, previous, scope) {
                            if (current && current.length) {
                                scope.rows = current;
                            }
                        }
                    }
                }
            };
        });
})();
